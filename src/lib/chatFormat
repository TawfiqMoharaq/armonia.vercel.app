@@ -1,7 +1,18 @@
// src/lib/chatFormat.ts
import type { ReactNode } from "react";

// ====== Helpers ======
/* -------------------- Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¥ÙŠÙ…ÙˆØ¬ÙŠ ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø²Ø®Ø±ÙÙŠØ© -------------------- */
// Ù†Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø¥ÙŠÙ…ÙˆØ¬ÙŠ + Ø±Ù…ÙˆØ² Ø´Ø§Ø¦Ø¹Ø© Ùˆ VARIATION SELECTOR/ZWJ
const EMOJI_REGEX =
  /[\u{1F300}-\u{1FAFF}\u{1F1E6}-\u{1F1FF}\u2600-\u27BF\u200D\uFE0F]/gu;
// Ø±Ù…ÙˆØ² Ø¨Ø¯Ø§ÙŠØ© Ø³Ø·Ø± Ù…Ø²Ø¹Ø¬Ø© (Ø£Ø³Ù‡Ù…/Ù†Ø¬ÙˆÙ…/Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª Ù†ØµÙŠØ©)
const LEADING_SYMBOLS = /^[\s\p{P}\p{S}Â·â€¢â—â–ªâ–«â—¦â†’â‡’â–¶â–ºâ˜…â˜†âœ“âœ”âœ¦âœ§âœ±â–âŠâ‹â—‡â—†â¬¤â¦¿â­‘â­’âšâœ¨ðŸŒŸâž¡ï¸â©â­ï¸ðŸ‘‰ðŸ‘ˆâ¬…ï¸âž¡ï¸â¬†ï¸â¬‡ï¸]+/u;

const stripEmojis = (s: string) => s.replace(EMOJI_REGEX, "");
const stripLeadingSymbols = (s: string) => s.replace(LEADING_SYMBOLS, "").trim();
const scrub = (s: string) => stripLeadingSymbols(stripEmojis(s));

/* --------------------------- Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø© Ø³Ø§Ø¨Ù‚Ø© -------------------------- */
export const stripBoldMarkers = (text: string) =>
  text.replace(/\*\*(.+?)\*\*/g, "$1").trim();

@@ -25,7 +36,7 @@ export const normalizeYoutubeLink = (url: string, fallbackKeywords?: string) =>
  return url;
};

// ===== Inline formatter =====
/* ------------------------- ØªÙ†Ø³ÙŠÙ‚ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø³Ø·Ø± (Ø±ÙˆØ§Ø¨Ø·) ------------------------ */
export const renderInline = (text: string, fallbackKeywords?: string): ReactNode[] => {
  const nodes: ReactNode[] = [];
  let remaining = text;
@@ -34,7 +45,6 @@ export const renderInline = (text: string, fallbackKeywords?: string): ReactNode
    if (!segment) return;
    const urlRegex = /(https?:\/\/[^\s)]+)/g;
    let lastIndex = 0;

    segment.replace(urlRegex, (url, _m, offset) => {
      if (offset > lastIndex) nodes.push(segment.slice(lastIndex, offset));
      const normalized = normalizeYoutubeLink(url, fallbackKeywords);
@@ -52,7 +62,6 @@ export const renderInline = (text: string, fallbackKeywords?: string): ReactNode
      lastIndex = offset + url.length;
      return "";
    });

    if (lastIndex < segment.length) nodes.push(segment.slice(lastIndex));
  };

@@ -62,9 +71,7 @@ export const renderInline = (text: string, fallbackKeywords?: string): ReactNode
      pushPlain(remaining);
      break;
    }
    if (urlMatch.index > 0) {
      pushPlain(remaining.slice(0, urlMatch.index));
    }
    if (urlMatch.index > 0) pushPlain(remaining.slice(0, urlMatch.index));
    const url = urlMatch[1];
    const normalized = normalizeYoutubeLink(url, fallbackKeywords);
    nodes.push(
@@ -84,14 +91,14 @@ export const renderInline = (text: string, fallbackKeywords?: string): ReactNode
  return nodes;
};

// ===== Parser =====

/* ------------------------------- Parser Ù…Ø±Ù† ------------------------------- */
export type ParsedSection = { title: string; paras: string[]; items: string[] };

const bulletRegex = /^([â€¢\-â€“â€”]|\d+[.)\-ØŒ]|[\u0660-\u0669]+[.)\-ØŒ])\s*/;

const isHeading = (s: string) => {
  const clean = stripBoldMarkers(s.replace(/^#+\s*/, "")).replace(/[.:ï¼š]+$/, "").trim();
  const noEmoji = scrub(s);
  const clean = stripBoldMarkers(noEmoji.replace(/^#+\s*/, "")).replace(/[.:ï¼š]+$/, "").trim();
  return (
    /^ØµØ¨Ø§Ø­/.test(clean) || /^Ù…Ø³Ø§Ø¡/.test(clean) || /^ØªÙ‡Ø¯Ø¦Ø©/.test(clean) ||
    /^ÙÙŠ Ø§Ù„Ù…ÙˆØ§Ù‚Ù/.test(clean) || /^Ø§Ù„Ù…ÙˆØ§Ù‚Ù/.test(clean) ||
@@ -101,26 +108,30 @@ const isHeading = (s: string) => {
};

export const normalizeTitle = (s: string) => {
  const t = stripBoldMarkers(s.replace(/^#+\s*/, "")).replace(/[.:ï¼š]+$/, "").trim();
  if (/Power\s*Up/i.test(t)) return "ØµØ¨Ø§Ø­Ù‹Ø§ (Power Up)";
  const t = stripBoldMarkers(scrub(s).replace(/^#+\s*/, "")).replace(/[.:ï¼š]+$/, "").trim();
  if (/Power\s*Up/i.test(t) || /^ØµØ¨Ø§Ø­/.test(t)) return "ØµØ¨Ø§Ø­Ù‹Ø§ (Power Up)";
  if (/Cooldown/i.test(t) || /^ØªÙ‡Ø¯Ø¦Ø©/.test(t) || /^Ù…Ø³Ø§Ø¡/.test(t)) return "Ù…Ø³Ø§Ø¡Ù‹ (ØªÙ‡Ø¯Ø¦Ø©)";
  if (/^Ø§Ù„Ù…ÙˆØ§Ù‚Ù/.test(t) || /^ÙÙŠ Ø§Ù„Ù…ÙˆØ§Ù‚Ù/.test(t)) return "ÙÙŠ Ø§Ù„Ù…ÙˆØ§Ù‚Ù Ø§Ù„ØµØ¹Ø¨Ø©";
  if (/^Ø§Ù„Ù…ÙˆØ§Ù‚Ù/.test(t) || /^ÙÙŠ Ø§Ù„Ù…ÙˆØ§Ù‚Ù/.test(t) || /^Ø¥Ø°Ø§/.test(t)) return "ÙÙŠ Ø§Ù„Ù…ÙˆØ§Ù‚Ù Ø§Ù„ØµØ¹Ø¨Ø©";
  return t;
};

// âœ… ÙƒÙ„ Ø¹Ù†ÙˆØ§Ù† Ù„ÙˆÙ† Ù…Ø®ØªÙ„Ù Ø­Ø³Ø¨ Ù†ÙˆØ¹Ù‡
/* --------- Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ø¹Ù†Ø§ÙˆÙŠÙ† (Ø¨Ø¯ÙˆÙ† Ø£ÙŠÙ‚ÙˆÙ†Ø§Øª â€“ ÙÙ‚Ø· Ø£Ù„ÙˆØ§Ù† Ù…Ø®ØªÙ„ÙØ©) ---------- */
export const iconAndClass = (title: string) => {
  if (/^ØµØ¨Ø§Ø­/.test(title)) return { cls: "text-[#00A6A6]" }; // ØªØ±ÙƒÙˆØ§Ø²
  if (/^ØµØ¨Ø§Ø­/.test(title)) return { cls: "text-[#00A6A6]" };     // ØªØ±ÙƒÙˆØ§Ø² ØµØ¨Ø§Ø­ÙŠ
  if (/^Ù…Ø³Ø§Ø¡/.test(title) || /^ØªÙ‡Ø¯Ø¦Ø©/.test(title)) return { cls: "text-[#7E60BF]" }; // Ø¨Ù†ÙØ³Ø¬ÙŠ Ù‡Ø§Ø¯Ø¦
  if (/^ÙÙŠ Ø§Ù„Ù…ÙˆØ§Ù‚Ù/.test(title) || /^Ø¥Ø°Ø§/.test(title)) return { cls: "text-[#E07A3F]" }; // Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ
  return { cls: "text-[#0A6D8B]" }; // Ù„ÙˆÙ† Armonia Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
  return { cls: "text-[#0A6D8B]" }; // Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
};

export function parseReply(text: string): ParsedSection[] {
  const lines = text.split(/\n+/).map((l) => l.trim()).filter(Boolean);
  // Ù†Ø¸Ù‘Ù Ø§Ù„Ø£Ø³Ø·Ø± Ù…Ù† Ø§Ù„Ø¥ÙŠÙ…ÙˆØ¬ÙŠ ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ù‚Ø¨Ù„ Ø£ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø©
  const lines = text
    .split(/\n+/)
    .map((l) => scrub(l.trim()))
    .filter(Boolean);

  const sections: ParsedSection[] = [];
  let current: ParsedSection | null = null;

  const push = () => { if (current) sections.push(current); current = null; };

  lines.forEach((line) => {
@@ -129,15 +140,13 @@ export function parseReply(text: string): ParsedSection[] {
      current = { title: normalizeTitle(line), paras: [], items: [] };
      return;
    }

    if (bulletRegex.test(line)) {
      current ??= { title: "ØªÙˆØµÙŠØ§Øª", paras: [], items: [] };
      current.items.push(stripBoldMarkers(line.replace(bulletRegex, "")));
      current.items.push(stripBoldMarkers(scrub(line.replace(bulletRegex, ""))));
      return;
    }

    current ??= { title: "ØªÙˆØµÙŠØ§Øª", paras: [], items: [] };
    current.paras.push(stripBoldMarkers(line));
    current.paras.push(stripBoldMarkers(scrub(line)));
  });

  push();
